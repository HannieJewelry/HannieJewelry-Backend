# Java Spring Boot REST API Format Rules (Haravan Spec, Blaze-Persistence, Cloudinary, UUID, Snake_case)

## 1. General Requirements

- **100% Haravan JSON schema compliance:**  
  All fields, types, and nesting must match the Haravan sample exactly. No missing or omitted fields.

- **ID Fields:**  
  All IDs use `UUID` (Java) and `uuid` (SQL). No integer or string IDs for resources or nested objects.

- **Image Uploads:**  
  Use Cloudinary. `src` fields must return the actual Cloudinary URL.

- **Mapping:**  
  Do **not** use MapStruct. Use Blaze-Persistence Entity View API Jakarta for output mapping.

- **Layered Architecture:**  
  Entity → Repository → DTO → Entity View → Service → Controller.

- **DTO Validation:**  
  All DTOs must use strong validation annotations (`@NotBlank`, `@Size`, `@NotNull`, etc.) as required by Haravan.

- **No Haravan API Calls:**  
  All data is managed locally in your database.

- **API Field Naming:**  
  Use `@JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy.class)` on all DTOs and Views. All API fields must be snake_case.

- **Response Wrapping:**  
  All responses use `ApiResponse`. Paging responses use `PagedResponse`.

- **Filtering & Paging:**  
  All GET endpoints must support Blaze-Persistence filtering and paging using `GenericFilterRequest`.

- **Configuration:**  
  Include all required configuration files (Jackson for snake_case, Blaze-Persistence, Cloudinary, `application.yaml`, etc.).

- **File Generation Order:**  
  If utility/config/filter classes are missing, generate those first.  
  For each domain: Entity → Repository → DTO → View → Service → Controller.

- **File Output Format:**  
  Show each file as:

---

## 2. Data Type Rules for E-Commerce (TMĐT)

**MANDATORY: Strictly follow these data type rules!**

1. **Price, Discount, Total Amount:**  
   Use `BigDecimal` (Java), `decimal` (SQL). Never use `Double`/`Float`.

2. **Quantity, Inventory:**  
   Use `Integer` (Java), non-null, default 0. Never use `Float`/`Double` or allow null.

3. **Boolean States:**  
   Use `boolean` or `Boolean` (Java). Never use `String` for boolean values or allow null.

4. **Order Codes, Product Codes:**  
   Use `String` (unique) or `UUID`.

5. **Date and Time:**  
   Use `Instant` (Java), always store and return as UTC. Never use non-standard strings or manually convert time zones.

6. **Email, Phone Number, Name, Address:**  
   Use `String` with `@NotBlank`, `@Size`, and format validation if applicable.

7. **Payment Amount, Shipping Fee, Vouchers, Discounts:**  
   Use `BigDecimal`/`decimal`.

8. **Foreign Key IDs:**  
   Use `UUID` or unique `String`, always with constraints (`@NotNull`, `@Column(unique = true)`).

> **Wrong data types in these fields will cause:**  
> Loss of money, bugs, manipulation, fraud, data loss, incorrect reporting, business logic errors, poor user experience, or inability to refund/cancel orders!

---

## 3. Rules for Position, Code, and Similar Fields

- **Fields related to position (e.g., `position`, `sort_order`, ...):**  
  Always assigned by service logic as max + 1 (auto-increment), never set by client.

- **Fields related to codes (e.g., `order_code`, `code`, ...):**  
  Always generated by service using business-specific random or formatted code logic, never set by client.

- **Applies to all similar fields:**  
  Any field representing position, code, or similar must follow these rules—never set by client, always generated by backend logic as per e-commerce standards.

- **Repository Query Style:**  
  Do **not** use `org.springframework.data.jpa.repository.Query` or Spring Data JPA query annotations in repository classes.  
  All custom queries (filtering, searching, sorting, paging) must use Blaze-Persistence QueryBuilder API and Entity View API for mapping in the Service layer.  
  Repository interfaces are for simple CRUD only (save, findById, delete, etc).  
  **No MapStruct, no JPQL in annotations, no imperative code, and no if statements in services.**

Must be similar to the sample code style of the controller and services project.

## 4. Documentation and Testing Rules

- **After successfully generating each API endpoint:**
  1. **Generate a standard action name** (e.g., `GET_Item_ById`, `POST_Item`, `PUT_Item_ById`, etc.).
  2. **Generate a full `curl` example** for the endpoint, including all required path, query, and body parameters (with sample values), and necessary headers.
  3. **All curl examples must use Postman-compatible environment variables (e.g., `{{BASE_URL}}`) for easy import into Postman.**
  4. **Append to a documentation `.md` file** (one file per resource, e.g., `item-api.md`), following this format:

```markdown
## [METHOD] [Endpoint]

- **Action name:** `[ACTION_NAME]`
- **Description:** [Short, clear description of what this API does]
- **curl example:**
  ```bash
  curl -X [METHOD] '{{BASE_URL}}/[Endpoint]' \
    -H 'Accept: application/json' \
    -H 'Authorization: Bearer {{ACCESS_TOKEN}}' \
    [--data-raw '{...}']


## 5. Code Change and Versioning Rule

- **Never delete or modify existing code or files.**
- All changes must be **additive**: Only add new code, or create a new version file (e.g., `ClassNameV2.java`, `ClassNameV3.java`, etc.).
- To change logic, always create a new version file/class, never change the old one.
- Mark old versions as `@Deprecated` if needed, but do not remove or edit them.
- All previous code must always be kept in the codebase.

## 6. Mandatory Code Style and Architecture Conformance Rule

- **No creativity, alternative style, or architectural changes are allowed.**
- All files, classes, layers, methods, patterns, and code style **must exactly match the existing samples in this module**.
- You must **analyze the provided code samples and replicate every detail**, including naming, annotations, dependency injection, imports, and class/method formatting.
- **Do not create new folders, new layers, or new design patterns. Do not apply personal preferences or improvements—even if you believe it is “cleaner” or “better.”**
- You may only add code, versions, or files **using the exact existing architecture and conventions**.
- All code must be 100% compatible and **interchangeable within this module**.
- Reviewers will reject any code that does not perfectly match the style, structure, and layering of the sample files.

> **Summary:**  
> **You must strictly adhere to the architecture, style, and conventions of this module—do not innovate, “improve,” or modify the structure in any way.**


package hanniejewelry.vn.product.controller;

import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import hanniejewelry.vn.product.dto.ItemRequest;
import hanniejewelry.vn.product.service.ItemService;
import hanniejewelry.vn.product.view.ItemView;
import hanniejewelry.vn.shared.dto.GenericFilterRequest;
import hanniejewelry.vn.shared.dto.RestResponse;
import hanniejewelry.vn.shared.utils.RestResponseUtils;
import hanniejewelry.vn.shared.dto.PagedResponse;
import hanniejewelry.vn.shared.utils.ResponseUtils;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.UUID;

@RestController
@RequestMapping("/api/items")
@RequiredArgsConstructor
public final class ItemController {

    private final ItemService itemService;

    @GetMapping("/{id}")
    public ResponseEntity<ApiResponse<ItemView>> getItemById(@PathVariable UUID id) {
        return ApiResponseUtils.successResponse(itemService.getItemViewById(id));
    }

    @PostMapping
    public ResponseEntity<ApiResponse<ItemView>> createItem(@Valid @RequestBody ItemRequest request) {
        return ApiResponseUtils.createdResponse(
                itemService.createItemAndReturnView(request)
        );
    }

    @PutMapping("/{id}")
    public ResponseEntity<ApiResponse<ItemView>> updateItem(
            @PathVariable UUID id, @Valid @RequestBody ItemRequest request) {
        return ApiResponseUtils.successResponse(
                itemService.updateItemAndReturnView(id, request)

        );
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<ApiResponse<Void>> deleteItem(@PathVariable UUID id) {
        itemService.deleteItem(id);
        return ApiResponseUtils.successResponse(null);
    }

    @GetMapping("/bp/view")
    public ResponseEntity<ApiResponse<PagedResponse<ItemView>>> getItemsByBlazeFilter(
            @ModelAttribute GenericFilterRequest filter) {
        return ApiResponseUtils.successResponse(
                ResponseUtils.pagedSuccess(itemService.getAllItemsWithBlazeFilter(filter), filter)

        );
    }
}

package hanniejewelry.vn.product.service;

import com.blazebit.persistence.CriteriaBuilderFactory;
import com.blazebit.persistence.PagedList;
import com.blazebit.persistence.view.EntityViewManager;
import com.blazebit.persistence.view.EntityViewSetting;
import jakarta.persistence.EntityManager;
import jakarta.transaction.Transactional;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import hanniejewelry.vn.product.dto.ItemRequest;
import hanniejewelry.vn.product.entity.Item;
import hanniejewelry.vn.product.repository.ItemRepository;
import hanniejewelry.vn.product.view.ItemView;
import hanniejewelry.vn.shared.filter.GenericBlazeFilterApplier;
import hanniejewelry.vn.shared.dto.GenericFilterRequest;
import org.springframework.stereotype.Service;

import java.util.UUID;

@Service
@Transactional
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
@RequiredArgsConstructor
public class ItemService {

    EntityViewManager evm;
    ItemRepository itemRepository;
    CriteriaBuilderFactory cbf;
    EntityManager em;
    private final GenericBlazeFilterApplier<ItemView> filterApplier = new GenericBlazeFilterApplier<>();

    public PagedList<ItemView> getAllItemsWithBlazeFilter(GenericFilterRequest filter) {
        var setting = EntityViewSetting.create(ItemView.class, filter.getPage(), filter.getSize());
        filterApplier.applyFilters(setting, filter);

        var cb = cbf.create(em, Item.class);
        filterApplier.applySort(cb, filter);

        return evm.applySetting(setting, cb).getResultList();
    }

    public ItemView createItemAndReturnView(ItemRequest request) {
        Item saved = itemRepository.save(Item.builder()
                .name(request.getName())
                .description(request.getDescription())
                .build());
        itemRepository.flush();
        return evm.find(em, ItemView.class, saved.getId());
    }

    public ItemView updateItemAndReturnView(UUID id, ItemRequest request) {
        Item updated = itemRepository.findById(id)
                .orElseThrow()
                .toBuilder()
                .name(request.getName())
                .description(request.getDescription())
                .build();
        Item saved = itemRepository.save(updated);
        itemRepository.flush();
        return evm.find(em, ItemView.class, saved.getId());
    }

    public void deleteItem(final UUID id) {
        itemRepository.findById(id)
                .orElseThrow();
        itemRepository.softDeleteById(id);
        itemRepository.flush();
    }

    public ItemView getItemViewById(UUID id) {
        itemRepository.findById(id)
                .orElseThrow();
        return evm.find(em, ItemView.class, id);
    }
}


